# coding:utf-8
# モジュールインポート
import json
import pprint
import binascii
import re
import csv
import urllib.parse
import os
import slack
import subprocess
import sys
import urllib.parse
import datetime
import time
#ファイルパス/APIキー読み込み
from config import *
#マルウェアURL抽出用正規表現
from pattern import *
import requests
from requests.exceptions import ConnectionError
from datetime import datetime
import hashlib
import argparse
import random
import string

#変数定義
#過去に検知したマルウェア一覧
malware_list = []


# 引数でフォルダパスを指定
args = sys.argv
try:
    logfile = args[1] # honeytrap logfile
except IndexError as e:
    print("Error:", e)
    print("Please set payload file.")
    print("ex: python3 <honeytrap_malware_check.py> <log_file>")
    sys.exit()

#メイン関数
def main():
    #過去に検知したマルウェアリストを読み込み
    malware_list = func_csv_open(malware_result_file)

    # 引数にて読み込みファイルを決定
    # 第一引数にnowを指定している場合、現在のログファイルを読み込み
    #args = sys.argv
    #if (args[1] == 'now'):
    #    logfile = honeytrap_logfile_now
    #else:
    #    logfile = honeytrap_logfile

    with open(logfile) as lines:
        for line in lines:
            try:
                honeytrap_data = json.loads(line)
            except Exception as e:
                #エラーの場合、実行
                print('error: ',e,'payload_info: ',line)
            
            #ペイロード情報が空でない場合に実行
            if honeytrap_data['attack_connection']['payload']['data_hex'] != "":
                #マルウェアURLが含まれているかチェックを行う
                malware_list = func_malware_url_check(honeytrap_data,malware_list)

def func_csv_open(file):
    #過去に検知したマルウェアリストを読み込み
    malware_list = []
    with open(file) as f:
        reader = csv.reader(f)
        header = next(reader)
        for row in reader:
            malware_list.append(row[1])

    return malware_list

def func_malware_url_check(honeytrap_data, malware_list):
    #マルウェアを含むURLがないか確認する関数
    #hexをデコード
    honeytrap_data_hex = str(bytes.fromhex(honeytrap_data['attack_connection']['payload']['data_hex']))
    honeytrap_data_hex = urllib.parse.unquote(honeytrap_data_hex)
    honeytrap_data_hex = re.sub("\\\\",'', honeytrap_data_hex)
    honeytrap_data_hex = re.sub("^b'",'', honeytrap_data_hex)
    honeytrap_data_hex = re.sub("^b\"",'', honeytrap_data_hex)
    honeytrap_data_hex = re.sub("'$",'', honeytrap_data_hex)
    honeytrap_data_hex = re.sub("\"$",'', honeytrap_data_hex)
    
    # マルウェアダウンロードを狙ったものであるか判定
    for pattern_regex in pattern:
        result = re.match(pattern_regex, honeytrap_data_hex,re.IGNORECASE)
        #正規表現に一致した場合、実行
        if result != None:
            #検索するフラグを設定
            malware_cheaked='NO'
            #マルウェアURL
            malware_url = result.group(1)
            #malware_listが含まれていない場合、実行しない
            if (len(malware_list) != 0):
                for malware_list_url in malware_list:
                    if (malware_url  == malware_list_url):
                        #過去に実行している場合、マルウェア取得を行わない
                        malware_cheaked='YES'
                        break

            if(malware_cheaked == 'NO'):
                # 過去に検知したマルウェアではない場合、記録
                # マルウェアダウンロードを実行する関数
                hash_data, status_code, malware_file=func_wget_malware(malware_url)

                # csvに出力
                # csv 書き込み用の変数を定義
                # 検知日付を定義
                start_time = honeytrap_data['@timestamp']
                start_time = re.match("(.*?)T", start_time, re.IGNORECASE)
                start_time = str(start_time.group(1))
                local_port = honeytrap_data['attack_connection']['local_port']
                remote_ip = honeytrap_data['attack_connection']['remote_ip']
                virus_total = 'NO' # virustotalチェック用 NO=未解析
                #生ペイロード
                raw_payload = honeytrap_data['attack_connection']['payload']['data_hex']
                #csv用のデータを生成
                csv_data=[start_time,malware_url,virus_total, remote_ip,local_port,status_code,malware_file, 
                        pattern_regex, hash_data['md5'],hash_data['sha1'],hash_data['sha256'],honeytrap_data_hex]
                func_malware_csv_write(csv_data) #csvファイル書き込み

                # ホワイトリストへ追加
                malware_list.append(malware_url)
                
                # shellの場合、URLが含まれていないか確認
                malware_url_shell, pattern_regex_shell, malware_list, file_payload=func_shell_file_check(malware_file, malware_list)
                if (len(malware_url_shell) != 0):
                    for i in range(len(malware_url_shell)):
                        hash_data, status_code, malware_file = func_wget_malware(malware_url_shell[i])
                        csv_data = [start_time, malware_url_shell[i], virus_total,remote_ip, local_port, status_code, malware_file, 
                                pattern_regex_shell[i], hash_data['md5'],hash_data['sha1'],hash_data['sha256'],file_payload[i]]
                        func_malware_csv_write(csv_data)

    return malware_list


def func_wget_malware(malware_url):
    #マルウェア取得関数
    print('Start Analysis malware url' + ':', malware_url)
    # wget ヘッダを付与
    headers = {'User-Agent': 'Wget/1.12'}
    try:
        r = requests.get(malware_url, headers=headers, stream=True, timeout=5.0)
        # なんらかのレスポンスがあった場合、以下を実行
        print('Status Code is ', r.status_code)
        if r.status_code == 200:
            #15桁のランダムなファイル名を定義
            chars = string.ascii_letters + string.digits
            n = 15
            s = ''
            random_file_name = s.join([random.choice(chars) for i in range(n)])
            malware_file = malware_path + random_file_name
            with open(malware_file , 'wb') as f:
                f.write(r.content)
                # ハッシュ値取得 md5,sha1,sha256
                hash_data=func_hash(malware_file)

                #ファイル名のリネーム Malware_md5ハッシュ値
                malware_file_rename = malware_path + 'Malware_' + hash_data['sha256']
                os.rename(malware_file, malware_file_rename)
                return hash_data, r.status_code, malware_file_rename
        else: 
            #ファイルダウンロードが出来なかった場合に実行
            #md5_hash='No Hash'
            hash_data={"md5":'No Hash',"sha1":'No Hash',"sha256":'No Hash'}
            malware_file = 'No file'
            return hash_data, r.status_code, malware_file

    except Exception as e: 
        #エラーの場合、実行
        print(e)
        now_time=str(datetime.now().strftime("%Y/%m/%d %H:%M:%S"))
        error = 'time:' + now_time +', type:' + str(type(e)) + ', type:' + str(type(e)) + ', args:' + str(e.args) +  ', error:' + str(e)
        with open(error_file , 'a') as f:
            writer=csv.writer(f)
            writer.writerow(error)

        status_code='error'
        hash_data={"md5":'No Hash',"sha1":'No Hash',"sha256":'No Hash'}
        malware_file = 'No file'
        return hash_data, status_code, malware_file

def func_hash(filePath):
    # sha1
    hash = hashlib.sha1()
    with open(filePath, 'rb') as fr:
        while True:
            chunk = fr.read(2048 * hash.block_size)
            if len(chunk) == 0:
                break

            hash.update(chunk)

    digest = hash.hexdigest()

    # md5
    hash = hashlib.md5()
    with open(filePath, 'rb') as fr:
        while True:
            chunk = fr.read(2048 * hash.block_size)
            if len(chunk) == 0:
                break

            hash.update(chunk)
    digest_md5 = hash.hexdigest()

    # sha256
    hash = hashlib.sha256()
    with open(filePath, 'rb') as fr:
        while True:
            chunk = fr.read(2048 * hash.block_size)
            if len(chunk) == 0:
                break

            hash.update(chunk)
    digest_sha256 = hash.hexdigest()

    hash_data={"md5":digest_md5,"sha1":digest,"sha256":digest_sha256}
    
    return hash_data

def func_malware_csv_write(csv_data): 
    #csvファイルへの書き込み
    with open(malware_result_file , 'a') as f:
            writer=csv.writer(f)
            writer.writerow(csv_data)
            #Slackへ情報連携
            func_slack_send(csv_data,slack_channel_new_malware)

# slackへ送信
def func_slack_send(data, channel):
    message="New Malware Detection \r\n"
    slack_headers = {'Content-Type': 'application/json'}

    for i in data:
        message= message + str(i) + '\r\n'

    params = {"token":SLACK_API_TOKEN, "channel": channel, "text": message}

    r = requests.get('https://slack.com/api/chat.postMessage',
                      headers=slack_headers,
                      params=params)

def func_shell_file_check(malware_file,malware_list):
    # 変数定義
    malware_url_shell = []
    pattern_regex_shell = []
    file_payload = []
    # fileコマンドの実行
    cmd = 'file ' + malware_file
    res = subprocess.check_output(cmd.split())
    #shell ファイルもしくはtextファイルであるか確認
    result = re.search(r'script', str(res), re.IGNORECASE)
    if result == None:
        result = re.search(r'text', str(res), re.IGNORECASE)
    #一致した場合、以下を実行
    if result != None:
        shell_file = open(malware_file)
        lines = shell_file.readlines()
        shell_file.close()
        #マルウェアURLが含まれていないか確認
        for line in lines:
            for pattern_regex in pattern:
                result = re.match(pattern_regex, line, re.IGNORECASE)
                if result != None:
                    malware_url=result.group(1)
                    malware_cheaked = 'NO'
                    for malware_list_url in malware_list:
                        # 調査済みであるか確認
                        if (malware_url == malware_list_url):
                            malware_cheaked = 'YES'
                            break

                    if (malware_cheaked == 'NO'):
                        pattern_regex_shell.append(pattern_regex)
                        malware_url_shell.append(malware_url)
                        malware_list.append(malware_url)
                        file_payload.append(line)

    return malware_url_shell, pattern_regex_shell, malware_list,file_payload


if __name__ == "__main__":
    main()
